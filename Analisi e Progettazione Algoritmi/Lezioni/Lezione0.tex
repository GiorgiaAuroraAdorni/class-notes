\section{Introduzione}

\subsection{Chiarimenti sul corso}

\begin{enumerate}
    \item Ricevimento U14 1010 1$^\circ$ piano;
    \item \href{mailto:zandron@disco.unimib.it}{zandron@disco.unimib.it};
    \item Modalità d'esame: \begin{enumerate}
        \item Scritto: esercizi + teoria;
        \item Verbalizzazione normale;
        \item Compitini: \begin{enumerate}
            \item 1o: esercizi;
            \item 2o: esercizi + teoria.
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

\subsection{A grandi linee}

\subsubsection{Programmazione dinamica}
La programmazione dinamica è un metodo di risoluzione dei problemi che consiste nel trovare sotto-informazioni che poi verranno riutilizzate con il tempo. Il problema viene spezzato in parti, e si cerca di trovare una sotto-informazione che può essere sfruttata quando necessario. Efficiente in termini di spazio e tempo. 

Alcuni algoritmi hanno una soluzione intuitiva, ma che richiedono di ricalcolare tante volte la stessa cosa. Una soluzione può essere usare una \textbf{cache}, memoria dove vengono salvati i valori calcolati precedentemente. A questo punto, però, l'algoritmo è meno efficiente dal punto di vista dello \textbf{spazio}. Bisogna quindi capire in quali casi è opportuno attuare una tecnica del genere. 

La programmazione dinamica viene usata nei problemi di ottimizzazione e di decisione. Gli algoritmi di decisione devono saper rispondere a ogni tipo di input (es. esiste un cammino che collega due nodi?). 

Un altro problema è la ricerca: dato un input $x$, determinare una soluzione $S$ che rispetti le caratteristiche del problema. Deve esistere $S$ tale che esista un collegamento $(x,\ S)$. 

L'ottimizzazione associa a ogni soluzione il relativo costo e cerca la miglior soluzione possibile in base al costo minimo: $S^*\:|\:C(S^*) \leq C(S)$. \\
Bisogna considerare anche che alcune soluzioni non sono ammissibili.

\subsubsection{Programmazione reedy}
Il tipo di programmazione \textbf{greedy} (o \textbf{goloso}), viene usata per determinare la soluzione migliore tramite una serie di calcoli effettuati localmente, per esempio previsioni in base ai dati correnti. Non si conosce l'andamento dei dati nel futuro. \par
Una tecnica di programmazione \textbf{greedy} si basa sulla situazione attuale per capire cosa fare successivamente. \par
Esempio: problema del $travelling\ salesman$. La tecnica greedy continua a ridurre le possibilità di scelta, più avanti si va nell'algoritmo. Ciò significa che le scelte attuali di viaggio possono sembrare poco costose, ma poi magari ci si ritrova con le ultime scelte che hanno spese insostenibili. \par
In casi di questo tipo, un algoritmo \textbf{greedy} non è la scelta più adatta. Possiamo quindi fare la seguente osservazione:
\begin{definition}{Algoritmo Greedy}{greedy}
    Gli algoritmi di tipo greedy funzionano al meglio se tutti i pesi (o valori) delle scelte sono uguali a $1$.
\end{definition}
$$
\begin{tikzpicture}
    \matrix (m) [matrix of math nodes, row sep=2em,
    column sep=1em]{
    & & c_1 & & \\
    c_2 & & & & c_3 \\
    & c_4 & & c_5 & \\};
    \path[-stealth]
    (m-1-3) edge (m-2-1) % c1
            edge (m-2-5)
            edge (m-3-2)
            edge (m-3-4)
    (m-2-1) edge (m-2-5) % c2
            edge (m-2-5)
            edge (m-3-2)
            edge (m-1-3)
            edge (m-3-4)
    (m-2-5) edge (m-2-1) % c3
            edge (m-1-3)
            edge (m-3-4)
            edge (m-3-2)
    (m-3-2) edge (m-1-3) % c4
            edge (m-2-1)
            edge (m-2-5)
            edge (m-3-4)
    (m-3-4) edge (m-1-3) % c5
            edge (m-2-1)
            edge (m-2-5)
            edge (m-3-2);
\end{tikzpicture}
$$

Alcuni algoritmi sui grafi implementabili con uno dei due metodi di programmazione sono BFS, DFS, cammini minimi, problemi di flusso.
Quando nessun algoritmo è in grado di risolvere un problema in tempo accettabile (non esponenziale) si parla di NP-completezza.