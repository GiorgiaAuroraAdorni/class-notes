\section{Codici di Hamming}
Il codice di Hamming è un codice ottimale che serve per correggere un errore nella trasmissione di un messaggio. Si basa sul modello del rumore bianco, ed è una soluzione algebrica.

Su $n$ bit trasmessi, ce ne sono $k$ che costituiscono il messaggio e $m$ di controllo, con $n = k + m$. Ci sono $2^m$ configurazioni relative a $n + 1$ eventi, quindi per coprire tutte le possibilità $2^m \geq n + 1 = m + k + 1$.

Il numero di bit si vuole minimizzare, quindi si cercano i minimi valori in grado di rispettare la disequazione: è necessario capire quante cifre di messaggio possono essere coperte dalle cifre di controllo. Dato che il codice è ottimale, esso userà il numero massimo di cifre di messaggio permesse.

Le configurazioni veramente ottimali sono quelle in cui la disuguaglianza è in realtà un'uguaglianza: $n = 2^m - 1$. Le cifre di controllo vanno quindi disposte in modo da coprire perfettamente tutti i bit del messaggio, ma in alcuni casi potrebbero esserci sovrapposizioni. Le equazioni di parità dovrebbero essere indipendenti tra loro. 

Esempio in $\{0, 1\}^9$: \\
$c_1 = 1, 2, 5, 7, c_2 = 5 7, 8, 9, c_3 = 1, 2, 8, 9$ \\
I risultati vengono ottenuti tramite XOR, il quale permette di ottenere combinazioni lineari grazie alle somme modulo 2 e la selezione degli elementi con 1 (moltiplicazione per 1). Essendo $c_3$ composto da bit in posizioni già conosciuti, esso non dà informazioni aggiuntive: le equazioni devono quindi essere linearmente indipendenti.

Ogni configurazione dei bit di controllo ($2^m$) introduce una sindrome, a cui va aggiunto il valore 000 che indica l'assenza di errori. Lo scopo della sindrome è il riconoscimento della posizione dell'errore: per esempio, $110$ rappresenta un errore nella posizione 6.

Le posizioni per calcolare le varie cifre di controllo sono quelli dove è presente un 1, considerando che le altre non cambiano. I bit delle posizioni con 1 per ogni cifra di controllo sono linearmente indipendenti. 

Esempio: $k = 4, m = 3 \rightarrow n = 7$ \\
Messaggio: $c_1c_21c_3011$ \\ 
Il numero di 1 dei bit coperti da ogni $c$ dev'essere pari, e ogni $c$ copre al più $k$ bit, quindi la codifica del messaggio sarà $0110011$. \\
Se il messaggio viene alterato, l'equazione di parità non viene più rispettata e il bit compromesso viene individuato dalla sindrome. 

Esempio: $0110111$, si ha che $c_1$ ha 1 pari, $c_2$ anche, ma $c_3$ ne ha 3, quindi l'errore è nella posizione 5. Questo valore è stato ottenuto sommando i valori di $c$.

Le posizioni di $c$ vengono scelte tra quelle che devono avere necessariamente 1 e che non hanno già un ruolo nel calcolo delle precedenti, oppure non hanno già bit coperti. In generale, i controlli si trovano nelle posizioni $2^0, 2^1, 2^2, 2^3, 2^4, \dots$

Un vantaggio di questo metodo è che i calcoli possono essere eseguiti in parallelo, quindi più velocemente. Se la sindrome è 0 non ci sono stati errori: il numero di 1 nei bit di messaggio è pari, quindi $c_i = 0$.


